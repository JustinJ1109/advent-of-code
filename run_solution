#!/usr/bin/python3

import argparse
import importlib
import os
import re
import sys

### import all the _<YEAR> files in the project
current_dir = os.path.dirname(__file__)
year_module_pattern = re.compile(r"_20[0-9]{2}")

for item in os.listdir(current_dir):
    item_path = os.path.join(current_dir, item)
    if os.path.isdir(item_path) and year_module_pattern.search(item):
        module = importlib.import_module(f"{item}", package=None)
        globals()[item] = module
###

def parse_args() -> argparse.Namespace:
    ap = argparse.ArgumentParser()

    ap.add_argument("-y", "--year", default=None, help="The year of the selected advent solution to execute (ex. '2025')")
    ap.add_argument("-d", "--day", default=None, help="The day of the selected advent solution to execute (ex. '1')")
    ap.add_argument("-c", "--test-case", default=None, help="Optional test case to run. This automatically pulls the relevant files from the \
                    './tests/case_X' directory, labeled as '{1,2}.in'. If a related {1,2}.out exists, a comparison will be ran and the output \
                    will either pass or fail if the inputs provide the expected out")
    return ap.parse_args()


if __name__ == "__main__":
    args = parse_args()

    if args.year is None:
        args.year = sorted(
            [mod for mod in globals().keys() if year_module_pattern.search(mod)],
            reverse=True,
        )[0][1:]
        print(f"No year specified, defaulting to last year: {args.year}")
    elif f"_{args.year}" not in globals().keys():
        print(
            f"No advent of code data found for year {args.year}. Expected a directory named: '{os.path.join(current_dir, '_' + args.year)}'",
            file=sys.stderr,
        )
        exit(1)

    year_module = globals()[f"_{args.year}"]

    if args.day is None:
        args.day = sorted(
            [mod for mod in dir(year_module) if mod.startswith("day_")], reverse=True
        )[0][len("day_") :]
        print(f"No day specified, defaulting to last day: {args.day}")
    elif f"day_{args.day}" not in dir(year_module):
        print(
            f"No day found for {args.day} in year {args.year}. Expected a directory named: '{os.path.join(current_dir, '_' + args.year, 'day_' + args.day)}'",
            file=sys.stderr,
        )
        exit(1)

    day_module = getattr(year_module, f"day_{args.day}")

    print("~" * 20)
    print(f"Year {args.year} Day {args.day}")
    print("~" * 20)

    stdin = None
    if not sys.stdin.isatty():
        stdin = sys.stdin.readlines()

    if args.test_case is None and stdin is None:
        raise ValueError()
    elif args.test_case is not None and stdin is not None:
        raise ValueError()
    elif args.test_case is not None:
        test_case_dir = os.path.abspath(os.path.join(current_dir, f"_{args.year}", f"day_{args.day}", "tests", f"case_{args.test_case}"))

        if not os.path.exists(test_case_dir):
            raise FileNotFoundError()

        input_file = os.path.join(test_case_dir, "input.txt")
        
        if not os.path.exists(input_file):
            print(f"Could not find input file to process (looking for '{input_file}')")
            exit(0)

        output_file = lambda part: os.path.join(test_case_dir, f"{part}.out")

        with open(input_file, "r") as fp:
            solution_input = fp.readlines()
        for part in (1, 2):
            if os.path.exists(output_file(part)):
                with open(output_file(part), "r") as fp:
                    expected_solution = fp.read()
                    if expected_solution.isnumeric():
                        expected_solution = int(expected_solution)
            else:
                expected_solution = None

            try:
                solution_func = getattr(day_module.solution, f"solve_{part}")
            except AttributeError:
                print(
                    f"No solution function exists for part {part} solution for {args.year} day {args.day}",
                )
                continue

            solution = solution_func(solution_input)
            correct = expected_solution is not None and solution == expected_solution
            print(f"{'✅' if correct else '❌' if expected_solution is not None else ''} Part {part} Solution:\n{solution}")

            if expected_solution is not None:
                if not correct:
                    print(f"(Expected {expected_solution})\n")
    else:
        for part in (1,2):
            try:
                solution_func = getattr(day_module.solution, f"solve_{part}")
            except AttributeError:
                print(
                    f"No solution function exists for part {part} solution for {args.year} day {args.day}",
                )
                continue
            solution = solution_func(stdin)
            print(f"Part {part} Solution:\n{solution}\n")
